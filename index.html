<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Home-Road Safety Enforcement</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header class="global-nav">
    <nav class="nav-wrap">
            <a href="index.html" class="logo" aria-label="Home">
        <img src="Images/2022-australia-new-logo-design-removebg-preview.png" alt="Road Safety Enforcement logo" width="36" height="36" decoding="async" />
      </a>
      <ul class="menu" role="menubar">
        <li class="menu-item"><a aria-current="page" href="index.html">Home</a></li>
        <li class="menu-item"><a href="about.html">About Us</a></li>
        <li class="menu-item dropdown">
          <a href="#" class="trigger" aria-haspopup="true" aria-expanded="false">Analytics</a>
          <div class="panel" role="menu">
            <a href="fines.html" role="menuitem">Fines</a>
            <a href="positive_breath_tests.html" role="menuitem">Positive Breath Tests</a>
            <a href="positive_drug_tests.html" role="menuitem">Positive Drug Tests</a>
            <a href="alcohol_drug_tests.html" role="menuitem">Alcohol &amp; Drug Tests</a>
          </div>
        </li>
      </ul>
      <div class="nav-actions">
        <label for="colorSchemeSelect" class="sr-only">Color scheme</label>
        <select id="colorSchemeSelect" class="color-scheme-select" aria-label="Color scheme"></select>
      </div>
    </nav>
  </header>

  <main>
    <section class="contain hero-block" style="padding:36px 0 8px">
      <h1 style="margin:0;font-size:clamp(28px,6vw,48px);line-height:1.06">Road Safety Enforcement</h1>
      <p class="sub" style="max-width:720px;margin:12px auto 0;line-height:1.5">
        The map currently displays the <strong>Total Combined Enforcement Count</strong> by jurisdiction. Use the buttons below to switch datasets.
      </p>
    </section>

    <section class="contain" style="padding:16px 0;">
      <h2 style="margin:0 0 12px; font-size:24px; text-align:center;">Search Analytics</h2>
      <div class="search-wrap">
        <input type="text" id="analytics-search" placeholder="e.g., Fines, Breath Tests, Pie Chart..." />
      </div>
    </section>

    <section class="section contain" style="padding-top:18px">
      <div class="map-card card">
        <div id="map-aus" class="map-wrap"></div>
        <div id="map-tooltip" class="map-tooltip" role="tooltip" aria-hidden="true"></div>

        <div class="map-buttons">
          <button data-ds="overview" class="active">Overview</button>
          <button data-ds="breath">Positive Breath Tests</button>
          <button data-ds="drug">Positive Drug Tests</button>
          <button data-ds="alcohol">Alcohol &amp; Drug Tests</button>
        </div>
      </div>
    </section>
  </main>

  <footer class="contain footer">
    <p>Group 32 - Road Safety Enforcement</p>
  </footer>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="js/theme.js"></script>
  <script>
  (() => {
    // ===== Paths (match your folder tree) =====
    const GEO_URL = "data/aus-states.geojson";
    const MAP_FALLBACK = {
      breath:  { start:"#0e2922", end:"#7aa294" },
      drug:    { start:"#2b1a12", end:"#b98a6e" },
      alcohol: { start:"#1d1730", end:"#b7a3d9" },
      overview:{ start:"#400040", end:"#e6b3ff" }
    };
    const mapRamp = (key, t) => {
      const styles = getComputedStyle(document.documentElement);
      const start = styles.getPropertyValue(`--map-${key}-start`).trim() || MAP_FALLBACK[key].start;
      const end = styles.getPropertyValue(`--map-${key}-end`).trim() || MAP_FALLBACK[key].end;
      return d3.interpolateRgb(start, end)(t);
    };
    const DATASETS = {
      breath:  { file: "csv/data 2 - positive breath test.csv",  label: "Positive Breath Tests",  color: t => mapRamp("breath", t), format: d3.format(",") },
      drug:    { file: "csv/data 2 - positive drug test.csv",    label: "Positive Drug Tests",    color: t => mapRamp("drug", t), format: d3.format(",") },
      alcohol: { file: "csv/data 2 - alcohol and drug test.csv", label: "Alcohol & Drug Tests",   color: t => mapRamp("alcohol", t), format: d3.format(",") },
      overview:{ file: null, label: "Total Combined Enforcement Count", color: t => mapRamp("overview", t), format: d3.format(",") }
    };

    const wrap    = d3.select("#map-aus");
    const tooltip = d3.select("#map-tooltip");
    const buttons = d3.selectAll(".map-buttons button");

    let svg, g, features, projection, path;
    let cached = {};                 // key -> { map: Map(state->value), year: number|null }
    let currentDataset = "overview";    // default to Overview
    let currentMap = new Map();
    let currentYear = null;

    // ===== Helpers =====
    const stdState = (s) => {
      const aliases = {
        "nsw":"New South Wales","vic":"Victoria","qld":"Queensland","sa":"South Australia",
        "wa":"Western Australia","tas":"Tasmania","nt":"Northern Territory","act":"Australian Capital Territory"
      };
      if (!s) return "";
      const t = String(s).trim();
      const k = t.toLowerCase();
      return aliases[k] || t.replace(/\s+/g," ");
    };

    const parseNum = (v) => {
      if (v == null) return NaN;
      const s = String(v).replace(/,/g,"").trim();
      if (!s || /^n\/?a$/i.test(s)) return NaN;
      const n = +s;
      return Number.isFinite(n) ? n : NaN;
    };

    function banner(msg){
      let box = wrap.select(".map-error");
      if (box.empty()) box = wrap.append("div").attr("class","map-error");
      box.text(msg);
      console.warn("[Map]", msg);
    }

    function detectColumns(rows){
      if (!rows.length) return {stateCol:null, yearCol:null, valueCol:null};
      const cols = Object.keys(rows[0]);

      const stateCol =
        cols.find(c => /^(jurisdiction|state|jurisdiction_name)$/i.test(c)) ||
        cols.find(c => /name/i.test(c)) || null;

      const yearCol =
        cols.find(c => /^year$/i.test(c)) ||
        cols.find(c => /(\bcalendar\b|\bfiscal\b).*year/i.test(c)) || null;

      // Prefer obvious numeric columns; fallback to most-numeric
      const preferred = [
        /^(value|count|total|number|cases|tests|positives?)$/i,
        /(positive).*breath|breath.*positive/i,
        /(positive).*drug|drug.*positive/i
      ];
      let valueCol = null;
      for (const r of preferred){
        const hit = cols.find(c => r.test(c));
        if (hit) { valueCol = hit; break; }
      }
      if (!valueCol){
        const numericScore = (c) => rows.reduce((acc,r)=> acc + (Number.isFinite(parseNum(r[c]))?1:0), 0);
        const scored = cols
          .filter(c => c !== stateCol && c !== yearCol)
          .map(c => [c, numericScore(c)])
          .sort((a,b)=> a[1]-b[1]);
        if (scored.length && scored.at(-1)[1] > 0) valueCol = scored.at(-1)[0];
      }
      console.log("[DetectColumns]", { stateCol, yearCol, valueCol, cols });
      return { stateCol, yearCol, valueCol };
    }

    // New function to calculate the combined enforcement count
    async function ensureOverviewDataset(){
        if (cached["overview"] && cached["overview"].map.size > 0) return;

        const combinedMap = new Map();
        let maxYear = 0;

        // 1. Load and aggregate all three source datasets
        for (const key of ["breath", "drug", "alcohol"]) {
            const cfg = DATASETS[key];
            if (!cfg.file) continue;

            let rows = await d3.csv(cfg.file).catch(e => (console.error(e), []));
            if (!rows.length) continue;

            const { stateCol, yearCol, valueCol } = detectColumns(rows);
            if (!stateCol || !valueCol) {
                console.warn(`[Overview] Missing columns for ${key}. Skipping.`);
                continue;
            }

            // Find the latest year for this dataset
            let targetYear = null;
            if (yearCol) {
                const years = rows.map(r => parseNum(r[yearCol])).filter(Number.isFinite);
                if (years.length) targetYear = d3.max(years);
                // Filter rows to only include the latest year data for accurate aggregation
                if (Number.isFinite(targetYear)) rows = rows.filter(r => parseNum(r[yearCol]) === targetYear);
                maxYear = Math.max(maxYear, targetYear);
            }

            // Aggregate values into the combined map
            rows.forEach(r => {
                const st = stdState(r[stateCol]);
                const v = parseNum(r[valueCol]);
                if (!st || !Number.isFinite(v)) return;
                // Add the value to the existing total for this state
                combinedMap.set(st, (combinedMap.get(st) || 0) + v);
            });
        }

        cached["overview"] = { map: combinedMap, year: (maxYear > 0 ? maxYear : null) };
        console.log(`[Overview] Aggregated data for ${combinedMap.size} states. Max Year: ${maxYear}`);
    }

    async function ensureDataset(key){
      if (key === "overview"){
          await ensureOverviewDataset();
          return;
      }

      if (cached[key]) return;
      const cfg = DATASETS[key];
      // Original logic for "empty" (which is now replaced by "overview" as the default load)
      if (!cfg.file){ cached[key] = { map:new Map(), year:null }; return; }

      let rows = await d3.csv(cfg.file).catch(e => (console.error(e), []));
      if (!rows.length){ cached[key] = { map:new Map(), year:null }; return; }

      const { stateCol, yearCol, valueCol } = detectColumns(rows);
      if (!stateCol || !valueCol){
        banner(`Couldn't detect columns in ${cfg.file}. Ensure it has state & value columns.`);
        cached[key] = { map:new Map(), year:null };
        return;
      }

      let targetYear = null;
      if (yearCol){
        const years = rows.map(r => parseNum(r[yearCol])).filter(Number.isFinite);
        if (years.length) targetYear = d3.max(years);
        if (Number.isFinite(targetYear)) rows = rows.filter(r => parseNum(r[yearCol]) === targetYear);
      }

      const map = new Map();
      rows.forEach(r => {
        const st = stdState(r[stateCol]);
        const v  = parseNum(r[valueCol]);
        if (!st || !Number.isFinite(v)) return;
        map.set(st, (map.get(st) || 0) + v);
      });

      console.log(`[${key}] Using columns`, { stateCol, yearCol, valueCol, targetYear, size: map.size });
      cached[key] = { map, year: targetYear };
    }

    // ===== Layout & render =====
    function sizeSvg(){
      const w = wrap.node().clientWidth || 900;
      const h = Math.max(420, Math.round(w * 0.62));
      svg.attr("width", w).attr("height", h);
      return { w, h };
    }

    function drawPaths() {
      const sel = g.selectAll("path")
        .data(features, d => (d.properties?.STATE_NAME || d.properties?.STE_NAME16 || d.id));

      sel.join("path")
        .attr("stroke","rgba(255,255,255,0.28)")
        .attr("stroke-width",1)
        .attr("fill","rgba(255,255,255,0.06)")
        .attr("d", path) // set 'd' immediately to avoid "only after zoom" bug
        .style("cursor","pointer")
        .on("mouseenter", function(event, d) {
          const pathEl = d3.select(this);
          const originalFill = pathEl.attr("fill");
          pathEl.attr("data-original-fill", originalFill);
          
          // Brighten the state on hover
          const rgb = d3.rgb(originalFill);
          const brightened = rgb.brighter(0.6);
          
          pathEl.transition().duration(250)
            .attr("fill", brightened)
            .attr("stroke","rgba(255,255,255,0.9)")
            .attr("stroke-width",2.5)
            .style("filter","drop-shadow(0 0 10px rgba(255,255,255,0.4))");
        })
        .on("mousemove", (event, d) => {
          const { left, top } = svg.node().getBoundingClientRect();
          const name = (d.properties.STATE_NAME || d.properties.STE_NAME16 || d.properties.NAME || d.properties.name || "").trim();
          const key  = stdState(name);
          const cfg  = DATASETS[currentDataset];
          const pack = cached[currentDataset] || { map:new Map(), year:null };
          const v    = pack.map.get(key);
          const valueHtml = (Number.isFinite(v) ? cfg.format(v) : "<em>No data</em>");
          // The tooltip uses the label defined in the DATASETS object (e.g., "Total Combined Enforcement Count")
          const yearHtml  = (pack.year && currentDataset !== "empty") ? ` - Latest Year: ${pack.year}` : "";

          tooltip
            .style("left", (event.clientX - left + 14) + "px")
            .style("top",  (event.clientY - top  + 14) + "px")
            .attr("aria-hidden","false")
            .html(`
              <div style="font-weight:700;margin-bottom:2px">${name}</div>
              <div style="font-size:12px;opacity:.8">${cfg.label}${yearHtml}</div>
              <div style="margin-top:4px;font-weight:600">${valueHtml}</div>
            `);
        })
        .on("mouseleave", function() {
          const pathEl = d3.select(this);
          const originalFill = pathEl.attr("data-original-fill") || pathEl.attr("fill");
          
          pathEl.transition().duration(250)
            .attr("fill", originalFill)
            .attr("stroke","rgba(255,255,255,0.28)")
            .attr("stroke-width",1)
            .style("filter","none");
          
          tooltip.attr("aria-hidden","true");
        });
    }

    function recolor() {
      if (!g) return;
      const cfg  = DATASETS[currentDataset];
      const pack = cached[currentDataset] || { map:new Map(), year:null };

      // Check if data is truly empty, even for Overview (max will be 0)
      const values = Array.from(pack.map.values());
      const max = d3.max(values) || 0;
      const isDataEmpty = max === 0;

      if (isDataEmpty) {
        g.selectAll("path").transition().duration(400)
          .attr("fill","rgba(255,255,255,0.06)");
        tooltip.attr("aria-hidden","true");
        return;
      }

      const colorScale = d3.scaleSequential((t)=>cfg.color(Math.min(1,Math.max(0,t)))).domain([0, max]);

      g.selectAll("path").transition().duration(500)
        .attr("fill", d => {
          const state = stdState(d.properties.STATE_NAME || d.properties.STE_NAME16 || d.properties.NAME || d.properties.name);
          const v = pack.map.get(state);
          // Highlight high statistics: darker colors mean higher values (as per the sequential scale)
          return Number.isFinite(v) ? colorScale(v) : "rgba(255,255,255,0.06)";
        });
    }

    function fitAndRender(){
      sizeSvg();
      projection.fitSize([svg.attr("width"), svg.attr("height")], { type:"FeatureCollection", features });
      path = d3.geoPath().projection(projection);
      drawPaths();
      recolor();
    }

    async function init(){
      svg = wrap.append("svg").attr("class","map-svg");
      g   = svg.append("g").attr("class","map-layer");
      projection = d3.geoMercator();

      const geo = await d3.json(GEO_URL).catch(e => (console.error(e), null));
      if (!geo || !Array.isArray(geo.features)) { banner("Couldn't load GeoJSON."); return; }
      features = geo.features;

      // First render pass
      fitAndRender();
      // Load default 'overview' data immediately
      await ensureDataset("overview");
      recolor();

      // Default to Overview button active on load
      d3.select('.map-buttons button[data-ds="overview"]').classed("active", true);

      // Buttons (including "Overview")
      buttons.on("click", async function(){
        const id = this.dataset.ds;
        if (!DATASETS[id]) return;
        buttons.classed("active", false);
        d3.select(this).classed("active", true);

        currentDataset = id;
        await ensureDataset(id);
        recolor();
      });

      // Keep map correct on container size changes
      const ro = new ResizeObserver(() => fitAndRender());
      ro.observe(wrap.node());
      window.addEventListener("resize", fitAndRender, { passive:true });
    }

    init();
    window.addEventListener('colorSchemeChanged', () => { recolor(); });


    // ===== NEW SEARCH FUNCTIONALITY (With Glow Links) =====
    const SEARCH_OPTIONS = [
      // --- Pages ---
      { name: "Page: Fines", url: "fines.html" },
      { name: "Page: Positive Breath Tests", url: "positive_breath_tests.html" },
      { name: "Page: Positive Drug Tests", url: "positive_drug_tests.html" },
      { name: "Page: Alcohol & Drug Tests", url: "alcohol_drug_tests.html" },
      { name: "Page: About Us", url: "about.html" },
      
      // --- Specific Charts (Fines) ---
      { name: "Fines: Top States (Bar Chart)", url: "fines.html#barChart" },
      { name: "Fines: Total Over Time (Line Chart)", url: "fines.html#lineChart" },
      { name: "Fines: Share by State (Pie Chart)", url: "fines.html#pieChart" },

      // --- Specific Charts (Breath Tests) ---
      { name: "Breath Tests: Top States (Bar Chart)", url: "positive_breath_tests.html#barChart" },
      { name: "Breath Tests: Total Over Time (Line Chart)", url: "positive_breath_tests.html#lineChart" },
      { name: "Breath Tests: Share by State (Pie Chart)", url: "positive_breath_tests.html#pieChart" },

      // --- Specific Charts (Drug Tests) ---
      { name: "Drug Tests: Top States (Bar Chart)", url: "positive_drug_tests.html#barChart" },
      { name: "Drug Tests: Total Over Time (Line Chart)", url: "positive_drug_tests.html#lineChart" },
      { name: "Drug Tests: Share by State (Pie Chart)", url: "positive_drug_tests.html#pieChart" },
      
      // --- Specific Charts (Alcohol & Drug) ---
      { name: "Alc & Drug: Top States (Bar Chart)", url: "alcohol_drug_tests.html#barChart" },
      { name: "Alc & Drug: Total Over Time (Line Chart)", url: "alcohol_drug_tests.html#lineChart" },
      { name: "Alc & Drug: Share by State (Pie Chart)", url: "alcohol_drug_tests.html#pieChart" },
    ];

    const searchInput = document.getElementById('analytics-search');
    const searchWrap = document.querySelector('.search-wrap');

    function renderResults(query) {
      const existingResults = searchWrap.querySelector('.search-results');
      if (existingResults) existingResults.remove();

      if (!query.trim()) return;

      const filtered = SEARCH_OPTIONS.filter(option =>
        option.name.toLowerCase().includes(query.toLowerCase())
      );

      if (filtered.length === 0) return;

      const resultsList = document.createElement('ul');
      resultsList.className = 'search-results';
      resultsList.setAttribute('role', 'listbox');

      filtered.forEach(option => {
        const item = document.createElement('li');
        item.textContent = option.name;
        item.setAttribute('role', 'option');
        item.setAttribute('data-url', option.url);
        item.onclick = () => {
          window.location.href = option.url;
        };
        resultsList.appendChild(item);
      });

      searchWrap.appendChild(resultsList);
    }

    searchInput.addEventListener('input', (e) => {
      renderResults(e.target.value);
    });

    // Close results when clicking outside
    document.addEventListener('click', (e) => {
      if (!searchWrap.contains(e.target)) {
        const existingResults = searchWrap.querySelector('.search-results');
        if (existingResults) existingResults.remove();
      }
    });
  })();
  </script>
</body>
</html>







